<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3Dブロック積み木アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Inter', sans-serif; 
            background-color: #ffffff;
            touch-action: manipulation;
        }
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block; 
        }
        .controls { 
            position: absolute; 
            bottom: 30px;
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            flex-wrap: nowrap;
            justify-content: center; 
            gap: 8px;
            padding: 10px; 
            background-color: rgba(255,255,255,0.85); 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.08);
            z-index: 10;
        }
        .action-button { 
            padding: 8px 12px;
            background-color: #f4f4f5;
            color: #18181b;
            border: 1px solid #d4d4d8;
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 16px; 
            transition: background-color 0.3s; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            white-space: nowrap;
        }
        .action-button:hover { background-color: #e4e4e7; }
        .action-button.orange { 
            background-color: #f59e0b;
            color: white;
            border-color: #d97706;
        }
        .action-button.orange:hover { background-color: #d97706; }
        .action-button.active {
            background-color: #a1a1aa;
            color: white;
            border-color: #71717a;
        }
        .action-button.active:hover {
            background-color: #71717a;
        }
        
        .panel {
            position: absolute; 
            background-color: rgba(255,255,255,0.85); 
            border-radius: 8px; 
            padding:10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.08);
            z-index: 10;
        }

        #block-controls-panel { 
            bottom: 30px;
            right: 20px; 
            display: grid; 
            grid-template-areas: ". up ." "left . right" ". down ." "y-up y-up y-up" "y-down y-down y-down"; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 5px; 
            width: 160px; 
        }

        #layer-controls-panel {
            bottom: 30px;
            left: 20px;
            width: 160px;
        }
        #layer-controls-panel .title, #rotation-controls-panel .title {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }
        #layer-controls-panel .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        #layer-controls-panel .layer-info {
            grid-column: 1 / -1;
            text-align: center;
            padding: 5px;
            font-size: 14px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        #reset-layers, #toggle-center-point {
            grid-column: 1 / -1;
        }

        #rotation-controls-panel {
            bottom: 280px;
            right: 20px;
            width: 160px;
            display: none;
        }
        #rotation-controls-panel .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .move-block-button, .rotate-button { background-color: #d4d4d8; color:#3f3f46; border:none; border-radius:5px; width:100%; height:35px; display:flex; justify-content:center; align-items:center; cursor:pointer; font-size: 14px; transition: background-color 0.3s; }
        .move-block-button:hover, .rotate-button:hover { background-color: #a1a1aa; }
        #move-z-plus { grid-area: up; font-size: 18px; }
        #move-x-minus { grid-area: left; font-size: 18px; }
        #move-x-plus { grid-area: right; font-size: 18px; }
        #move-z-minus { grid-area: down; font-size: 18px; }
        #move-y-plus { grid-area: y-up; }
        #move-y-minus { grid-area: y-down; }

        #instructionText { position: absolute; top: 20px; right: 20px; padding: 8px 12px; background-color: rgba(0,0,0,0.05); color: #333; border: 1px solid rgba(0,0,0,0.1); border-radius: 5px; font-size: 13px; z-index: 10; text-align: right; }
        #loading-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 30px; background-color: rgba(0,0,0,0.75); color: white; border-radius: 8px; font-size: 18px; z-index: 2500; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .custom-modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .custom-modal-content { background-color: #fefefe; margin: auto; padding: 25px; border: 1px solid #bbb; width: 90%; max-width: 500px; border-radius: 10px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.25); position: relative; }
        .custom-modal-close { color: #888; position: absolute; top: 10px; right: 15px; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        .custom-modal-close:hover, .custom-modal-close:focus { color: #333; text-decoration: none; }
        #customModalMessage { font-size: 16px; color: #333; margin-top: 10px; margin-bottom: 15px; }

        #loginModal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 3000; }
        #loginBox { background-color: white; padding: 30px 40px; border-radius: 10px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        #loginBox h3 { margin-top: 0; color: #333; }
        #nicknameInput { width: 100%; padding: 10px; margin: 15px 0; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; }
        #loginButton, #anonymousButton { width: 100%; padding: 10px; border-radius: 5px; border: none; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        #loginButton { background-color: #3b82f6; color: white; margin-bottom: 10px; }
        #loginButton:hover { background-color: #2563eb; }
        #anonymousButton { background-color: #6b7280; color: white; }
        #anonymousButton:hover { background-color: #4b5563; }
        #logoutButton { display: none; }
        
        #userInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.1);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            color: #333;
            display: none;
            text-align: right;
            z-index: 10;
        }

        #saveModal .save-new-section { margin: 20px 0; display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap;}
        #saveModal input[type="text"] { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; flex-grow: 1; min-width: 180px; }
        #saveModal button { padding: 8px 15px; border-radius: 4px; border: none; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        #saveNewButton { background-color: #10b981; color: white; }
        #saveNewButton:hover { background-color: #059669; }
        #savedStatesList { margin-top: 20px; max-height: 40vh; overflow-y: auto; text-align: left; border-top: 1px solid #eee; padding-top: 10px; }
        .saved-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #eee; gap: 10px; }
        .saved-item-name { font-weight: bold; flex-grow: 1; }
        .saved-item-date { font-size: 12px; color: #666; }
        .saved-item-actions button { font-size: 14px; margin-left: 5px; }
        .load-button { background-color: #3b82f6; color: white; }
        .load-button:hover { background-color: #2563eb; }
        .delete-save-button { background-color: #f97316; color: white; }
        .delete-save-button:hover { background-color: #ea580c; }

        #confirmModal .custom-modal-content { max-width: 350px; }
        .confirm-actions { margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        
        #confirmNoButton {
            background-color: #d4d4d8;
            color: #3f3f46;
            border: none;
        }
        #confirmNoButton:hover {
            background-color: #a1a1aa;
        }
    </style>
</head>
<body>
    <div id="loginModal">
        <div id="loginBox">
            <h3>ニックネームでログイン</h3>
            <p style="font-size:14px; color:#555;">他のデバイスと作品を共有できます</p>
            <input type="text" id="nicknameInput" placeholder="ニックネームを入力">
            <button id="loginButton">この名前で始める</button>
            <button id="anonymousButton">ログインせずに続ける</button>
        </div>
    </div>

    <div id="container"></div>
    <div id="loading-indicator">処理中...</div>

    <div id="instructionText">タップで選択<br>ダブルタップで作成</div>
    <div id="userInfo"></div>
    
    <div class="controls">
        <button id="groupButton" class="action-button">グループ化</button>
        <button id="saveLoadButton" class="action-button">保存/読込</button>
        <button id="deleteButton" class="action-button">削除</button>
        <button id="fixViewButton" class="action-button">視点固定</button>
        <button id="logoutButton" class="action-button">ログアウト</button>
    </div>

    <div id="layer-controls-panel" class="panel">
        <div class="title">レイヤー操作</div>
        <div class="button-group">
            <button id="layer-down" class="move-block-button">▼</button>
            <button id="layer-up" class="move-block-button">▲</button>
            <div id="layer-info" class="layer-info">全表示</div>
            <button id="reset-layers" class="action-button">全表示</button>
            <button id="toggle-center-point" class="action-button">中心非表示</button>
        </div>
    </div>
    
    <div id="rotation-controls-panel" class="panel">
        <div class="title">回転</div>
         <div class="button-group">
            <button id="rotate-y" class="rotate-button">横回転</button>
            <button id="rotate-x" class="rotate-button">縦回転</button>
        </div>
    </div>

    <div id="block-controls-panel" class="panel">
        <button id="move-z-plus" class="move-block-button" data-axis="z" data-dir="-1" title="手前へ移動">▲</button>
        <button id="move-x-minus" class="move-block-button" data-axis="x" data-dir="-1" title="左へ移動">◀</button>
        <button id="move-x-plus" class="move-block-button" data-axis="x" data-dir="1" title="右へ移動">▶</button>
        <button id="move-z-minus" class="move-block-button" data-axis="z" data-dir="1" title="奥へ移動">▼</button>
        <button id="move-y-plus" class="move-block-button" data-axis="y" data-dir="1" title="上へ移動">上へ</button>
        <button id="move-y-minus" class="move-block-button" data-axis="y" data-dir="-1" title="下へ移動">下へ</button>
    </div>

    <div id="customModal" class="custom-modal"><div class="custom-modal-content"><span id="customModalClose" class="custom-modal-close" title="閉じる">&times;</span><p id="customModalMessage"></p></div></div>
    <div id="saveModal" class="custom-modal"><div class="custom-modal-content"><span id="saveModalClose" class="custom-modal-close" title="閉じる">&times;</span><h3>保存と読込</h3><div class="save-new-section"><input type="text" id="saveNameInput" placeholder="作品名 (例: はじめての城)"><button id="saveNewButton">現在の状態で新規保存</button></div><div id="savedStatesList"><p>保存した作品はありません。</p></div></div></div>
    <div id="confirmModal" class="custom-modal"><div class="custom-modal-content"><p id="confirmModalMessage"></p><div class="confirm-actions"><button id="confirmYesButton" class="action-button">はい</button><button id="confirmNoButton" class="action-button">いいえ</button></div></div></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, getDocs, deleteDoc, onSnapshot, query, serverTimestamp, writeBatch, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBk-lnmwZnhPTj3yQuMfRBc3u5HFXko95k",
            authDomain: "tsumiki3d.firebaseapp.com",
            projectId: "tsumiki3d",
            storageBucket: "tsumiki3d.firebasestorage.app",
            messagingSenderId: "245181141529",
            appId: "1:245181141529:web:a95fa288ab74de8ceb5088"
        };
        
        const appId = firebaseConfig.appId;
        
        let app, auth, db, userId, currentNickname = null;
        let cubesCollectionRef, savesCollectionRef;
        let isAuthReady = false;
        let unsubscribeFromCubes = null;

        const loadingIndicator = document.getElementById('loading-indicator');
        const customModal = document.getElementById('customModal');
        const customModalMessage = document.getElementById('customModalMessage');
        const customModalClose = document.getElementById('customModalClose');
        const saveModal = document.getElementById('saveModal');
        const saveModalClose = document.getElementById('saveModalClose');
        const confirmModal = document.getElementById('confirmModal');
        const confirmModalMessage = document.getElementById('confirmModalMessage');
        const confirmYesButton = document.getElementById('confirmYesButton');
        const confirmNoButton = document.getElementById('confirmNoButton');
        
        const loginModal = document.getElementById('loginModal');
        const nicknameInput = document.getElementById('nicknameInput');
        const loginButton = document.getElementById('loginButton');
        const anonymousButton = document.getElementById('anonymousButton');
        const logoutButton = document.getElementById('logoutButton');
        const userInfo = document.getElementById('userInfo');
        
        if (customModalClose) customModalClose.onclick = () => customModal.style.display = "none";
        if (saveModalClose) saveModalClose.onclick = () => saveModal.style.display = "none";
        window.onclick = event => { 
            if (event.target == customModal) customModal.style.display = "none";
            if (event.target == saveModal) saveModal.style.display = "none";
            if (event.target == confirmModal) confirmModal.style.display = "none";
        }

        function showUserMessage(message) {
            console.warn("UserMessage:", message);
            if (customModal && customModalMessage) {
                customModalMessage.textContent = message;
                customModal.style.display = "flex";
            }
        }

        function showConfirmation(message, onConfirm) {
            confirmModalMessage.textContent = message;
            confirmModal.style.display = 'flex';
            confirmYesButton.onclick = () => {
                confirmModal.style.display = 'none';
                onConfirm();
            };
            confirmNoButton.onclick = () => {
                confirmModal.style.display = 'none';
            };
        }
        
        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                return new Promise((resolve, reject) => {
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else {
                            try {
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                            } catch (error) {
                                reject(error);
                                return;
                            }
                        }

                        if (!userId) {
                            reject(new Error("ユーザーIDの取得に失敗しました。"));
                            return;
                        }
                        
                        const basePath = currentNickname 
                            ? `artifacts/${appId}/nicknames/${currentNickname.replace(/[\.#$\[\]]/g, '_')}`
                            : `artifacts/${appId}/users/${userId}`;

                        cubesCollectionRef = collection(db, `${basePath}/cubes`);
                        savesCollectionRef = collection(db, `${basePath}/saves`);
                        
                        userInfo.textContent = currentNickname ? `ログイン中: ${currentNickname}` : 'オフラインモード';
                        userInfo.style.display = 'block';
                        logoutButton.style.display = currentNickname ? 'block' : 'none';

                        isAuthReady = true; 
                        resolve(); 
                    });
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showUserMessage("アプリの起動に失敗しました: " + error.message); 
                return Promise.reject(error);
            }
        }

        let scene, camera, renderer, orbitControls;
        let invisiblePlane, centerPoint;
        const cubes = [];
        const cubeDataMap = new Map();
        
        let isGroupMode = false;
        const groupSelection = new Set();
        const cubeGroups = [];
        let selectedGroup = null;
        let selectedCube = null;

        let minLayer = 0.5;
        let maxLayer = 0;
        let currentVisibleLayer = Infinity;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const cubeSize = 1;
        const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

        let lastTouchTime = 0;
        const DOUBLE_TAP_TIMEOUT = 300;
        let touchStartPointer = { x: 0, y: 0 };
        const MAX_TAP_MOVE_THRESHOLD = 20;

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 15;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            if (event.pointerType === 'touch') {
                touchStartPointer.x = event.clientX;
                touchStartPointer.y = event.clientY;
            }
        }

        function onCanvasClick(event) { if (event.pointerType !== 'touch') onCanvasClickLogic(); }
        async function onCanvasDblClick(event) { if (event.pointerType !== 'touch') onCanvasDblClickLogic(); }
        
        function onCanvasTouchEnd(event) {
            const currentTime = new Date().getTime();
            const timeSinceLastTouch = currentTime - lastTouchTime;
            const touch = event.changedTouches[0]; 
            if (!touch) return; 
            const rect = renderer.domElement.getBoundingClientRect();
            const deltaX = Math.abs(touch.clientX - touchStartPointer.x);
            const deltaY = Math.abs(touch.clientY - touchStartPointer.y);
            if (deltaX < MAX_TAP_MOVE_THRESHOLD && deltaY < MAX_TAP_MOVE_THRESHOLD) {
                event.preventDefault();
                pointer.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                pointer.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                if (timeSinceLastTouch < DOUBLE_TAP_TIMEOUT) { onCanvasDblClickLogic(); lastTouchTime = 0; } 
                else { onCanvasClickLogic(); lastTouchTime = currentTime; }
            } else { lastTouchTime = 0; }
        }

        function initThreeJS() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 15;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            camera.zoom = 1.2;
            camera.updateProjectionMatrix();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, visible: false, side: THREE.DoubleSide });
            invisiblePlane = new THREE.Mesh(planeGeometry, planeMaterial);
            invisiblePlane.rotation.x = -Math.PI / 2;
            scene.add(invisiblePlane);

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.target.set(0, cubeSize / 2, 0);

            const centerPointGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const centerPointMaterial = new THREE.MeshBasicMaterial({ color: 0xf59e0b });
            centerPoint = new THREE.Mesh(centerPointGeometry, centerPointMaterial);
            centerPoint.position.copy(orbitControls.target);
            scene.add(centerPoint);

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            renderer.domElement.addEventListener('dblclick', onCanvasDblClick, false);
            renderer.domElement.addEventListener('touchend', onCanvasTouchEnd, false);
            document.getElementById('groupButton').addEventListener('click', handleGroupButtonClick);
            document.getElementById('saveLoadButton').addEventListener('click', openSavePanel);
            document.getElementById('deleteButton').addEventListener('click', deleteSelection);
            document.getElementById('fixViewButton').addEventListener('click', toggleViewpointFix);
            
            setupBlockControls();
            setupLayerControls();
            setupRotationControls();
            setupCenterPointToggle();
            animate();
        }
        
        function setupCenterPointToggle() {
            document.getElementById('toggle-center-point').addEventListener('click', (e) => {
                if (centerPoint) {
                    centerPoint.visible = !centerPoint.visible;
                    e.target.textContent = centerPoint.visible ? '中心非表示' : '中心表示';
                }
            });
        }
        
        function setupLayerControls() {
            document.getElementById('layer-up').addEventListener('click', () => changeLayer(1));
            document.getElementById('layer-down').addEventListener('click', () => changeLayer(-1));
            document.getElementById('reset-layers').addEventListener('click', resetLayers);
        }

        function updateLayerState() {
            const oldMaxLayer = maxLayer;
            if (cubes.length > 0) {
                const yPositions = cubes.map(c => c.position.y);
                maxLayer = Math.max(...yPositions);
                minLayer = Math.min(...yPositions);
            } else {
                maxLayer = 0;
                minLayer = 0.5;
            }

            if (currentVisibleLayer === Infinity || oldMaxLayer !== maxLayer) {
                currentVisibleLayer = maxLayer;
            }
            
            if (currentVisibleLayer > maxLayer) {
                currentVisibleLayer = maxLayer;
            }
            if (currentVisibleLayer < minLayer) {
                currentVisibleLayer = minLayer;
            }
            
            updateLayerVisibility();
        }

        function updateLayerVisibility() {
            cubes.forEach(cube => {
                cube.visible = cube.position.y <= currentVisibleLayer;
            });
            const layerInfo = document.getElementById('layer-info');

            if (Math.abs(currentVisibleLayer - maxLayer) < 0.01) {
                layerInfo.textContent = '全表示';
            } else {
                const displayLayer = Math.round((currentVisibleLayer - 0.5) / cubeSize) + 1;
                if (displayLayer > 0) {
                     layerInfo.textContent = `${displayLayer}段目まで表示`;
                } else if (displayLayer === 0) {
                     layerInfo.textContent = `地下1段目まで表示`;
                }
                 else {
                     layerInfo.textContent = `地下${1 - displayLayer}段目まで表示`;
                }
            }
        }
        
        function changeLayer(direction) {
            let newLayer = currentVisibleLayer + direction * cubeSize;
            
            if (direction === -1 && newLayer < minLayer) {
                newLayer = minLayer;
            }
            if (direction === 1 && newLayer > maxLayer) {
                newLayer = maxLayer;
            }

            if (Math.abs(newLayer - currentVisibleLayer) < 0.01) return;
            
            currentVisibleLayer = newLayer;
            updateLayerVisibility();
        }

        function resetLayers() {
            currentVisibleLayer = maxLayer;
            updateLayerVisibility();
        }
        
        async function openSavePanel() {
            if (!isAuthReady) { showUserMessage("データベースの準備ができていません。"); return; }
            if (!currentNickname) { showUserMessage("作品を保存・読込するにはニックネームでのログインが必要です。"); return; }
            const savedStatesList = document.getElementById('savedStatesList');
            saveModal.style.display = 'flex';
            savedStatesList.innerHTML = '<p>読込中...</p>';
            try {
                const querySnapshot = await getDocs(query(savesCollectionRef));
                if (querySnapshot.empty) {
                    savedStatesList.innerHTML = '<p>保存した作品はありません。</p>';
                    return;
                }
                savedStatesList.innerHTML = '';
                const saves = [];
                querySnapshot.forEach(doc => saves.push({ id: doc.id, ...doc.data() }));
                saves.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
                saves.forEach(data => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'saved-item';
                    itemDiv.innerHTML = `
                        <span class="saved-item-name">${data.name || '無題の作品'}</span>
                        <span class="saved-item-date">${data.createdAt ? new Date(data.createdAt.toMillis()).toLocaleString() : '日付不明'}</span>
                        <div class="saved-item-actions">
                            <button class="load-button" data-id="${data.id}">読込</button>
                            <button class="delete-save-button" data-id="${data.id}" data-name="${data.name || '無題の作品'}">削除</button>
                        </div>`;
                    savedStatesList.appendChild(itemDiv);
                });
                savedStatesList.querySelectorAll('.load-button').forEach(b => b.addEventListener('click', (e) => loadState(e.target.dataset.id)));
                savedStatesList.querySelectorAll('.delete-save-button').forEach(b => b.addEventListener('click', (e) => deleteState(e.target.dataset.id, e.target.dataset.name)));
            } catch (error) {
                console.error("Error fetching saved states:", error);
                showUserMessage("作品リストの読込に失敗しました。");
            }
        }
        
        async function saveCurrentState() {
            if (!currentNickname) { showUserMessage("作品を保存するにはニックネームでのログインが必要です。"); return; }
            const saveNameInput = document.getElementById('saveNameInput');
            const saveName = saveNameInput.value.trim();
            if (!saveName) { showUserMessage("作品名を入力してください。"); return; }
            if (cubes.length === 0) { showUserMessage("保存するブロックがありません。"); return; }
            loadingIndicator.style.display = 'block';
            const cubesData = cubes.map(cube => ({
                x: cube.position.x, y: cube.position.y, z: cube.position.z
            }));
            try {
                await addDoc(savesCollectionRef, { name: saveName, createdAt: serverTimestamp(), cubes: cubesData });
                saveNameInput.value = '';
                await openSavePanel();
            } catch (error) { showUserMessage("作品の保存に失敗しました。"); } 
            finally { loadingIndicator.style.display = 'none'; }
        }
        
        async function loadState(saveId) {
            if (!isAuthReady) { showUserMessage("データベースの準備ができていません。"); return; }
            saveModal.style.display = 'none';
            loadingIndicator.style.display = 'block';

            if (unsubscribeFromCubes) {
                unsubscribeFromCubes();
                unsubscribeFromCubes = null;
            }

            try {
                const currentCubesSnapshot = await getDocs(cubesCollectionRef);
                const deleteBatch = writeBatch(db);
                currentCubesSnapshot.forEach(d => deleteBatch.delete(d.ref));
                await deleteBatch.commit();
                
                const saveDoc = await getDoc(doc(savesCollectionRef, saveId));
                if (!saveDoc.exists()) throw new Error("保存データが見つかりません。");
                const savedCubesData = saveDoc.data().cubes;
                const saveName = saveDoc.data().name;

                const addBatch = writeBatch(db);
                savedCubesData.forEach(cubeData => {
                    const newCubeRef = doc(cubesCollectionRef);
                    addBatch.set(newCubeRef, {
                        x: cubeData.x,
                        y: cubeData.y,
                        z: cubeData.z
                    });
                });
                await addBatch.commit();
                
                showUserMessage(`「${saveName}」を読み込みました。`);

            } catch(error) {
                console.error("Error loading state:", error);
                showUserMessage("作品の読み込みに失敗しました: " + error.message);
            } finally {
                loadingIndicator.style.display = 'none';
                loadCubesFromFirestore();
            }
        }

        function deleteState(saveId, saveName) {
            showConfirmation(`「${saveName}」を本当に削除しますか？`, async () => {
                loadingIndicator.style.display = 'block';
                try {
                    await deleteDoc(doc(savesCollectionRef, saveId));
                    await openSavePanel();
                } catch(error) { showUserMessage("保存データの削除に失敗しました。"); } 
                finally { loadingIndicator.style.display = 'none'; }
            });
        }

        function setupBlockControls() {
            document.getElementById('block-controls-panel').addEventListener('click', (e) => {
                if(e.target.classList.contains('move-block-button')) {
                    const axis = e.target.dataset.axis;
                    const direction = parseInt(e.target.dataset.dir);
                    moveSelection(axis, direction);
                }
            });
        }
        
        function setupRotationControls() {
            document.getElementById('rotate-y').addEventListener('click', () => rotateGroup('y'));
            document.getElementById('rotate-x').addEventListener('click', () => rotateGroup('x'));
        }
        
        async function rotateGroup(axis) {
            if (!selectedGroup || selectedGroup.length === 0) {
                showUserMessage("回転するグループを選択してください。");
                return;
            }

            const groupBox = new THREE.Box3();
            selectedGroup.forEach(cube => groupBox.expandByPoint(cube.position));
            const center = new THREE.Vector3();
            groupBox.getCenter(center);

            let pivotCube = selectedGroup[0];
            let min_dist_sq = pivotCube.position.distanceToSquared(center);

            for (let i = 1; i < selectedGroup.length; i++) {
                const dist_sq = selectedGroup[i].position.distanceToSquared(center);
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    pivotCube = selectedGroup[i];
                }
            }
            const pivotPoint = pivotCube.position.clone();

            const quaternion = new THREE.Quaternion();
            const angle = Math.PI / 2;
            const rotationAxis = axis === 'y' ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);
            quaternion.setFromAxisAngle(rotationAxis, angle);

            const newPositions = new Map();
            for (const cube of selectedGroup) {
                const relativePos = cube.position.clone().sub(pivotPoint);
                relativePos.applyQuaternion(quaternion).round(); 
                const newPos = pivotPoint.clone().add(relativePos);
                newPositions.set(cube, newPos);
            }
            
            let collision = false;
            const allOtherCubes = cubes.filter(c => !selectedGroup.includes(c));

            for (const newPos of newPositions.values()) {
                for (const otherCube of allOtherCubes) {
                    if (newPos.distanceTo(otherCube.position) < 0.1) {
                        collision = true;
                        break;
                    }
                }
                if (collision) break;
            }

            if (collision) {
                showUserMessage("回転できません（他のブロックと衝突します）。");
                return;
            }

            const batch = writeBatch(db);
            newPositions.forEach((pos, cube) => {
                const docRef = doc(cubesCollectionRef, cube.userData.firestoreId);
                batch.update(docRef, { x: pos.x, y: pos.y, z: pos.z });
            });

            try {
                await batch.commit();
                newPositions.forEach((pos, cube) => cube.position.copy(pos));
            } catch (error) {
                console.error("Rotation failed:", error);
                showUserMessage("回転処理に失敗しました。");
            }
        }

        function handleGroupButtonClick() {
            if (selectedGroup) {
                ungroupSelectedGroup();
            } else {
                toggleGroupMode();
            }
        }

        function updateGroupButtonState() {
            const groupButton = document.getElementById('groupButton');
            const rotationPanel = document.getElementById('rotation-controls-panel');

            if (isGroupMode) {
                groupButton.textContent = 'グループ確定';
                groupButton.classList.add('active');
                rotationPanel.style.display = 'none';
            } else if (selectedGroup) {
                groupButton.textContent = 'グループ解除';
                groupButton.classList.add('active');
                rotationPanel.style.display = 'block';
            } else {
                groupButton.textContent = 'グループ化';
                groupButton.classList.remove('active');
                rotationPanel.style.display = 'none';
            }
        }

        function toggleGroupMode() {
            isGroupMode = !isGroupMode;

            if (!isGroupMode && groupSelection.size > 0) {
                const newGroupMembers = Array.from(groupSelection);

                const remainingGroups = cubeGroups
                    .map(group => group.filter(cube => !groupSelection.has(cube)))
                    .filter(group => group.length > 0);

                remainingGroups.push(newGroupMembers);
                
                cubeGroups.length = 0;
                cubeGroups.push(...remainingGroups);

                showUserMessage(`新しいグループを作成しました (${newGroupMembers.length}個)`);
                deselectAll();
            } else if (isGroupMode) {
                deselectAll();
            } else {
                isGroupMode = false;
            }
            
            updateGroupButtonState();
        }
        
        function ungroupSelectedGroup() {
            if (!selectedGroup) return;
            const index = cubeGroups.indexOf(selectedGroup);
            if (index > -1) {
                cubeGroups.splice(index, 1);
                showUserMessage(`グループを解除しました。`);
            }
            deselectAll();
        }

        function deselectAll() {
            cubes.forEach(c => c.material.color.setHex(0xffffff));
            groupSelection.clear();
            selectedCube = null;
            selectedGroup = null;
            updateGroupButtonState();
        }

        async function moveSelection(axis, direction) {
            const targets = selectedGroup ? selectedGroup : (selectedCube ? [selectedCube] : []);
            if (targets.length === 0) {
                showUserMessage("動かすブロックを選択してください。"); return;
            }

            const batch = writeBatch(db);
            let collision = false;
            
            const targetSet = new Set(targets);
            const otherCubes = cubes.filter(c => !targetSet.has(c));

            for (const target of targets) {
                const targetPosition = target.position.clone();
                targetPosition[axis] += direction * cubeSize;
                
                for (const otherCube of otherCubes) {
                    if (targetPosition.distanceTo(otherCube.position) < 0.99) {
                        collision = true; break;
                    }
                }
                if (collision) break;
            }

            if (collision) {
                showUserMessage("そこには動かせません。");
                return;
            }
            
            targets.forEach(target => {
                const newPos = target.position.clone();
                newPos[axis] += direction * cubeSize;
                const docRef = doc(cubesCollectionRef, target.userData.firestoreId);
                batch.update(docRef, { 
                    x: newPos.x, 
                    y: newPos.y, 
                    z: newPos.z 
                });
            });

            try {
                await batch.commit();
            } catch (error) {
                showUserMessage("移動に失敗しました。");
            }
        }
        
        async function deleteSelection() {
            const targets = selectedGroup ? [...selectedGroup] : (selectedCube ? [selectedCube] : []);
            if (targets.length === 0) {
                showUserMessage("削除するブロックを選択してください。");
                return;
            }

            showConfirmation(`${targets.length}個のブロックを削除しますか？`, async () => {
                const batch = writeBatch(db);
                const deletedCubeIds = new Set();

                targets.forEach(target => {
                    if (target.userData.firestoreId) {
                        const docRef = doc(cubesCollectionRef, target.userData.firestoreId);
                        batch.delete(docRef);
                        deletedCubeIds.add(target.userData.firestoreId);
                    }
                });

                try {
                    await batch.commit();
                    const remainingGroups = cubeGroups
                        .map(group => group.filter(cube => !deletedCubeIds.has(cube.userData.firestoreId)))
                        .filter(group => group.length > 0);
                    
                    cubeGroups.length = 0;
                    cubeGroups.push(...remainingGroups);

                    deselectAll();
                } catch (error) {
                    console.error("削除に失敗しました:", error);
                    showUserMessage("削除に失敗しました。");
                }
            });
        }
        
        function onCanvasClickLogic() {
            raycaster.setFromCamera(pointer, camera);
            const selectableCubes = cubes.filter(c => c.visible);
            const intersects = raycaster.intersectObjects(selectableCubes, false); 
            const clickedCube = intersects.length > 0 ? intersects[0].object : null;

            if (isGroupMode) {
                if (clickedCube) {
                    const containingGroup = cubeGroups.find(group => group.includes(clickedCube));
                    const targets = containingGroup ? containingGroup : [clickedCube];
                    
                    const isAdding = !groupSelection.has(clickedCube);

                    targets.forEach(c => {
                        if (isAdding) {
                            groupSelection.add(c);
                        } else {
                            groupSelection.delete(c);
                        }
                    });

                    cubes.forEach(c => {
                        if(groupSelection.has(c)) {
                            c.material.color.setHex(0xc0c0c0);
                        } else {
                            c.material.color.setHex(0xffffff);
                        }
                    });
                }
            } else {
                deselectAll();
                if (clickedCube) {
                    const containingGroup = cubeGroups.find(group => group.includes(clickedCube));
                    if (containingGroup) {
                        selectedGroup = containingGroup;
                        selectedGroup.forEach(c => c.material.color.setHex(0xe0e0e0));
                    } else {
                        selectedCube = clickedCube;
                        selectedCube.material.color.setHex(0xe0e0e0);
                    }
                }
            }
            updateGroupButtonState();
        }

        // ★★★ 変更した関数 ★★★
        async function onCanvasDblClickLogic() {
            if (isGroupMode) return;
            raycaster.setFromCamera(pointer, camera);
            const visibleCubes = cubes.filter(c => c.visible);
            
            // 1. まずブロックとの交差をチェック
            let cubeIntersects = raycaster.intersectObjects(visibleCubes, false);
            let intersect = null;

            if (cubeIntersects.length > 0) {
                // ブロックにヒットした場合
                intersect = cubeIntersects[0];
            } else {
                // ブロックにヒットしなかった場合、地面との交差をチェック
                let planeIntersects = raycaster.intersectObjects([invisiblePlane], false);
                if (planeIntersects.length > 0) {
                    intersect = planeIntersects[0];
                }
            }

            if (!intersect || !intersect.face) return; // 交差がなければ終了
            
            const newPosition = new THREE.Vector3();
            
            if (intersect.object === invisiblePlane) { 
                newPosition.set( Math.round(intersect.point.x), cubeSize / 2, Math.round(intersect.point.z) );
            } else { 
                newPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, cubeSize);
            }
            
            newPosition.x = Math.round(newPosition.x);
            newPosition.y = Math.round((newPosition.y - cubeSize/2) / cubeSize) * cubeSize + cubeSize/2;
            newPosition.z = Math.round(newPosition.z);
            
            let overlap = false;
            for (const cube of visibleCubes) {
                if (newPosition.distanceTo(cube.position) < 0.99) { 
                    overlap = true; 
                    break; 
                }
            }
            
            if (!overlap) {
                try {
                    await addDoc(cubesCollectionRef, { x: newPosition.x, y: newPosition.y, z: newPosition.z });
                } catch (e) { 
                    showUserMessage("ブロックの追加に失敗しました。"); 
                }
            } else { 
                showUserMessage("ここにはブロックを置けません。"); 
            }
        }
        
        function createCubeMesh(position, docId) {
            if (!docId || cubeDataMap.has(docId)) return null;
            
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            const cube = new THREE.Mesh(cubeGeometry, material);
            cube.position.copy(position);
            cube.userData.firestoreId = docId;

            const edgesGeom = new THREE.EdgesGeometry(cube.geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3 });
            const edges = new THREE.LineSegments(edgesGeom, lineMaterial);
            
            cube.add(edges); 
            cube.userData.edges = edges; 
            cubes.push(cube);
            scene.add(cube);
            cubeDataMap.set(docId, {x: position.x, y: position.y, z: position.z});
            return cube;
        }
        
        function toggleViewpointFix() {
            orbitControls.enabled = !orbitControls.enabled;
            const button = document.getElementById('fixViewButton');
            button.textContent = orbitControls.enabled ? '視点固定' : '固定解除';
            button.classList.toggle('orange', !orbitControls.enabled); 
        }

        function animate() {
            requestAnimationFrame(animate);
            if (orbitControls.enabled) orbitControls.update(); 
            renderer.render(scene, camera); 
        }

        async function loadCubesFromFirestore() {
            if (!isAuthReady) return;
            loadingIndicator.style.display = 'block';
            if (unsubscribeFromCubes) unsubscribeFromCubes(); 
            
            while(cubes.length > 0) {
                scene.remove(cubes.pop());
            }
            cubeDataMap.clear();
            cubeGroups.length = 0;
            deselectAll();

            unsubscribeFromCubes = onSnapshot(query(cubesCollectionRef), (snapshot) => {
                const changes = snapshot.docChanges();
                
                changes.filter(c => c.type === "removed").forEach(change => handleDocChange(change));
                changes.filter(c => c.type !== "removed").forEach(change => handleDocChange(change));

                updateLayerState();
                loadingIndicator.style.display = 'none';
            }, (error) => {
                console.error("Firestore Snapshot Error:", error);
                showUserMessage("データの同期に失敗しました。");
                loadingIndicator.style.display = 'none';
            });
        }

        function handleDocChange(change) {
            const data = change.doc.data();
            const docId = change.doc.id;

            if (change.type === "added") {
                if(typeof data.x === 'number' && typeof data.y === 'number' && typeof data.z === 'number') {
                    if (!cubeDataMap.has(docId)) {
                        createCubeMesh(new THREE.Vector3(data.x,data.y,data.z), docId);
                    }
                }
            } else if (change.type === "modified") {
                const c = cubes.find(c => c.userData.firestoreId === docId);
                if (c) { 
                    c.position.set(data.x,data.y,data.z);
                    cubeDataMap.set(docId, {x: data.x, y: data.y, z: data.z});
                }
            } else if (change.type === "removed") {
                const i = cubes.findIndex(c => c.userData.firestoreId === docId);
                if (i > -1) {
                    const cubeToRemove = cubes[i];
                    
                    if (selectedCube === cubeToRemove) selectedCube = null;
                    if (selectedGroup && selectedGroup.includes(cubeToRemove)) deselectAll();
                    groupSelection.delete(cubeToRemove);
                    
                    scene.remove(cubeToRemove);
                    cubes.splice(i, 1);
                    cubeDataMap.delete(docId);

                    const remainingGroups = cubeGroups
                        .map(group => group.filter(cube => cube !== cubeToRemove))
                        .filter(group => group.length > 0);
                    cubeGroups.length = 0;
                    cubeGroups.push(...remainingGroups);
                }
            }
        }
        
        async function startApp() {
            loadingIndicator.style.display = 'block';
            try {
                await initializeFirebase(); 
                initThreeJS(); 
                await loadCubesFromFirestore(); 
            } catch (error) {
                showUserMessage("アプリの起動処理でエラーが発生しました: " + error.message);
                loadingIndicator.style.display = 'none';
            }
        }
        
        function main() {
            loginButton.addEventListener('click', () => {
                const nickname = nicknameInput.value.trim();
                if (nickname) {
                    currentNickname = nickname;
                    localStorage.setItem('tsumiki_nickname', nickname);
                    loginModal.style.display = 'none';
                    startApp();
                } else {
                    showUserMessage("ニックネームを入力してください。");
                }
            });

            anonymousButton.addEventListener('click', () => {
                currentNickname = null;
                localStorage.removeItem('tsumiki_nickname');
                loginModal.style.display = 'none';
                startApp();
            });

            logoutButton.addEventListener('click', () => {
                showConfirmation("ログアウトしますか？", () => {
                    localStorage.removeItem('tsumiki_nickname');
                    location.reload();
                });
            });

            document.getElementById('saveNewButton').addEventListener('click', saveCurrentState);
            
            const savedNickname = localStorage.getItem('tsumiki_nickname');
            if (savedNickname) {
                currentNickname = savedNickname;
                loginModal.style.display = 'none';
                startApp();
            } else {
                loginModal.style.display = 'flex';
            }
        }
        
        main();
    </script>
</body>
</html>
